#!/usr/bin/env bash

# TODO: might need to check for /dev/dri and remove it from compose if not found
#        people having issues with permission on that dir (add plex to video group?)
# TODO: various configurations using cli
# TODO: Test permissions and integration
# TODO: add pihole


set -o errexit
set -o nounset
set -o pipefail


readonly LOG_FILE=/tmp/nateflix-$(date +%Y%m%d%H%M%S).log


check_installed()
{
  if hash nateflix 2>/dev/null; then
    echo "Nateflix is already installed. Please remove existing installation before continuing"
    echo "To remove nateflix run the command \"nateflix remove\""
    exit 1
  fi
}

check_ports()
{
  local ports="80 443 38258"
  local used=''
  local openPorts=$(lsof -Pi -n | grep -v "[-][>]" | grep -v "COMMAND")

  for port in $ports; do
    local result=$(grep ":${port} " <<< "${openPorts}" | tail -n 1)
    if [[ ! -z $result ]]; then
      used="${used},$(echo ${result}|cut -d ' ' -f 1):${port}"
    fi
  done

  if [[ -n ${used} ]]; then
    used=$(echo $used | cut -d ',' -f 2-)
    echo "Required ports are already in use (${used})"
    echo "These ports are required, please stop any services associated with these ports"
    exit 1
  fi
}

log()
{
  declare level="$1" message="$2" stdout="${3:-}"

  local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
  echo "${timestamp} [${level}] ${message}" >> "${LOG_FILE}"
  if [[ ${stdout} == 1 ]]; then
    echo "${message}"
  fi
}

get_var()
{
  declare var_name="$1" config_file="$2"

  source "${config_file}"
  echo "${!var_name}"
}

version_compare()
{
  declare first="$1" second="$2"

  # return 0 $1 == $2
  # return 1 $1 > $2
  # return 2 $1 < $2

  if [[ ${first} == ${second} ]]; then
    return 0
  fi

  local IFS=.
  local i ver1=($first) ver2=($second)

  # fill empty fields in ver1 with zeros
  for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
    ver1[i]=0
  done

  for ((i=0; i<${#ver1[@]}; i++)); do
    if [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi

    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi

    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done

  return 0
}

check_distro()
{
  export DISTRO=$(get_var ID /etc/os-release)
  export VERSION=$(get_var VERSION_ID /etc/os-release)

  if [[ -z $DISTRO ]]; then
    echo "Unable to determine linux distro"
    exit 1
  fi

  if [[ $(uname -m) != "x86_64" ]]; then
  	echo "This architecture is not supported ($(uname -m))"
  	exit 1
  fi

  local debVersion="7.7"
  local ubuVersion="14.04"
  local cenVersion="7"
  local fedVersion="26"

  if [[ "$DISTRO" == "debian" && $(version_compare $VERSION "${debVersion}"; echo $?) == 2 ]]; then
    echo "Requires Debian ${debVersion} or higher"
    exit 1
  elif [[ "$DISTRO" == "ubuntu" && $(version_compare $VERSION "${ubuVersion}"; echo $?) == 2 ]]; then
    echo "Requires Ubuntu ${ubuVersion} or higher"
    exit 1
  elif [[ "$DISTRO" == "centos" && $(version_compare $VERSION "${cenVersion}"; echo $?) == 2 ]]; then
    echo "Requires CentOS ${cenVersion} or higher"
    exit 1
  elif [[ "$DISTRO" == "fedora" && $(version_compare $VERSION "${fedVersion}"; echo $?) == 2 ]]; then
    echo "Requires Fedora ${fedVersion} or higher"
    exit 1
  fi

  export PACKAGE_UPDATE="apt-get -qq update"
  export PACKAGE_INSTALL="apt-get -qq -y install"

  if [[ ${DISTRO} == "centos" ]]; then
    PACKAGE_UPDATE=""
    PACKAGE_INSTALL="yum install -y"
  elif [[ ${DISTRO} == "fedora" ]]; then
    PACKAGE_UPDATE=""
    PACKAGE_INSTALL="dnf -y install"
  fi
}

cleanup()
{
  declare work_dir="$1"

  if [[ -d ${work_dir} ]]; then
    rm -rf "${work_dir}"
  fi
}

wait_for_service()
{
  declare url_path="$1" status="$2" content="$3" retries="${4:-20}"

  local url="http://localhost:38258${url_path}"
  local http_status='0'
  local http_content=''
  local out=''

  while [[ ${http_status} != ${status} || ! ${http_content} =~ ${content} ]]; do
    out=$(curl -k --silent -L -w "\n%{http_code}" "${url}" || true)
    http_status="${out##*$'\n'}"
    http_content="${out%$'\n'*}"
    retries=$((${retries}-1))
    if [[ ${retries} < 0 ]]; then
      echo "Service did not properly start"
      exit 1
    fi
    sleep 1
  done

  return 0
}

extract()
{
  declare self="$0" dest="$1"

  local archive=$(awk '/^__ARCHIVE__/ {print NR + 1; exit 0; }' "${self}")
  tail -n+${archive} "${self}" | tar xpJv -C "${dest}" >> "${LOG_FILE}" 2>&1
}

get_value()
{
    declare question="$1" default="$2"

    read -ep "${question} [${default}]? " value
    if [[ -n ${value} ]]; then
      echo "${value}"
    else
      echo "${default}"
    fi
}

check_prereqs()
{
  local reqDockerVersion="18.06.0"
  local reqDCVersion="1.23.1"

  if ! hash docker 2>/dev/null; then
    echo "docker is not installed"
    echo "please install the latest version of docker"
    echo "https://docs.docker.com/install/linux/docker-ce/${DISTRO}/"
    exit 1
  fi

  if ! hash docker-compose 2>/dev/null; then
    echo "docker-compose is not installed"
    echo "please install the latest version of docker compose"
    echo "https://docs.docker.com/compose/install/"
    exit 1
  fi

  local dockerVersion=$(docker --version|cut -d ' ' -f 3|cut -d ',' -f 1)
  local dcVersion=$(docker-compose --version|cut -d ' ' -f 3|cut -d ',' -f 1)
  if [[ $(version_compare "${dockerVersion}" "${reqDockerVersion}"; echo $?) == 2 ]]; then
    echo "Your docker version (${dockerVersion}) is not supported"
    echo "Version >= ${reqDockerVersion} is required"
    echo "Please update your docker https://docs.docker.com/install/linux/docker-ce/${DISTRO}/"
    exit 1
  fi

  if [[ $(version_compare "${dcVersion}" "${reqDCVersion}"; echo $?) == 2 ]]; then
    echo "Your docker-compose version (${dcVersion}) is not supported"
    echo "Version >= ${reqDCVersion} is required"
    echo "Please update your docker-compose https://docs.docker.com/compose/install/"
    exit 1
  fi

  systemctl start docker
}

install_dependencies()
{
  echo "Installing dependencies..."
  ${PACKAGE_UPDATE}
  ${PACKAGE_INSTALL} rsync sqlite3 curl openssl >> "${LOG_FILE}" 2>&1
}

get_plex_token()
{
  declare username="$1" password="$2"

  local result=$(curl -s --header "X-Plex-Client-Identifier: Nateflix" \
          --header "X-Plex-Product: Nateflix Installation" \
          --header "X-Plex-Version: V1" \
          -d "user[login]=${username}&user[password]=${password}" \
          -X POST https://plex.tv/users/sign_in.json)
  local re="^\{\"error\":\"(.+)\"\}$"
  if [[ $result =~ $re ]]; then
    log "ERROR" "Login failed: ${BASH_REMATCH[1]}" 1
    echo ""
    return 1
  elif [[ $result != *"{\"user\":"* ]]; then
    echo $result >> "${LOG_FILE}"
    log "ERROR" "Login failed: Unexpected result, try again (check ${LOG_FILE} for details)" 1
  else
    token=$(echo $result | grep -ioe '"authToken":"[^"]*' | cut -c 14-)
    if [[ -z ${token} ]]; then
      echo "Unable to parse plex login token"
      exit 1
    fi
  fi

  echo ${token}
  return 0
}

gather_required_config()
{
  echo
  echo
  echo "**************************"
  echo "* INITIAL CONFIGURATION  *"
  echo "**************************"
  echo

  if [[ -z ${CONFIG_DIR:-} ]]; then
    export CONFIG_DIR=/nateflix
  fi

  if [[ -z ${PLEX_USERNAME:-} && -z ${PLEX_PASSWORD:-} && -z ${PLEX_TOKEN:-} ]]; then
    log "INFO" "Gathering credentials..."
    while [[ -z ${PLEX_USERNAME:-} || -z ${PLEX_PASSWORD:-} && -z ${PLEX_TOKEN:-} ]]; do
      read -ep "Plex username: " PLEX_USERNAME
      read -esp "Plex password: " PLEX_PASSWORD
      echo
      if [[ -z ${PLEX_USERNAME} || -z ${PLEX_PASSWORD} ]]; then
        echo "Plex username and password required"
      elif [[ -n ${PLEX_USERNAME} && -n ${PLEX_PASSWORD} ]]; then
        PLEX_TOKEN=$(get_plex_token "${PLEX_USERNAME}" "${PLEX_PASSWORD}")
      fi
    done
  else
    echo "PLEX_CREDENTIALS:   ${PLEX_USERNAME}:********"
    PLEX_TOKEN=$(get_plex_token "${PLEX_USERNAME}" "${PLEX_PASSWORD}")
  fi

  export PLEX_USERNAME
  export PLEX_PASSWORD
  export PLEX_TOKEN

  if [[ -z ${PORTAL_USERNAME:-} && -z ${PORTAL_PASSWORD:-} ]]; then
    echo
    echo "Set credentials for web access to system portal"
    while [[ -z ${PORTAL_USERNAME:-} ]]; do
      read -ep "Portal Username: " PORTAL_USERNAME
      if [[ -z ${PORTAL_USERNAME} ]]; then
        echo "Portal username is required"
      else
        PORTAL_PASSWORD=$(openssl passwd -apr1 -quiet 2>/dev/null || true)
        while [[ -z ${PORTAL_PASSWORD} ]]; do
          PORTAL_PASSWORD=$(openssl passwd -apr1 -quiet 2>/dev/null || true)
        done
      fi
    done
  else
    echo "PORTAL_CREDENTIALS: ${PORTAL_USERNAME}:********"
    PORTAL_PASSWORD=$(echo ${PORTAL_PASSWORD}|openssl passwd -stdin -apr1 -quiet 2>/dev/null || true)
  fi

  export PORTAL_CREDS="${PORTAL_USERNAME}:${PORTAL_PASSWORD}"

  if [[ -z ${VPN_USERNAME:-} && -z $VPN_PASSWORD:-} ]]; then
    echo
    echo "Set credentials for Private Internet Access VPN"
    while [[ -z ${VPN_USERNAME:-} || -z ${VPN_PASSWORD:-} ]]; do
      read -ep "PIA VPN Username: " VPN_USERNAME
      read -esp "PIA VPN Password: " VPN_PASSWORD
      echo
      if [[ -z ${VPN_USERNAME} || -z ${VPN_PASSWORD} ]]; then
        echo "VPN username and password are required"
      fi
    done
  else
    echo "VPN_CREDENTIALS:    ${VPN_USERNAME}:********"
  fi

  export VPN_USERNAME
  export VPN_PASSWORD
  export VPN_REGION="US West"

  echo

  if [[ -z ${DOMAIN:-} ]]; then
    export DOMAIN=$(get_value "Nateflix domain name (FQDN if you have one)" "$(hostname).local")
  else
    echo "DOMAIN:      ${DOMAIN}"
  fi

  if [[ -z ${INSTALL_DIR:-} ]]; then
    export INSTALL_DIR=$(get_value "Install directory" "/opt/nateflix")
  else
    echo "INSTALL_DIR: ${INSTALL_DIR}"
  fi

  if [[ -z ${MEDIA_ROOT:-} ]]; then
    export MEDIA_ROOT=$(get_value "Root location of media library" "/mnt/media")
  else
    echo "MEDIA_ROOT:  ${MEDIA_ROOT}"
  fi
}

install()
{
  echo
  echo
  echo "**************************"
  echo "*  INSTALLING NATEFLIX   *"
  echo "**************************"
  echo

  log "INFO" "Extracting files" 1
  extract "${WORKING_DIR}"

  log "INFO" "Creating directories" 1
  mkdir -p "${INSTALL_DIR}"
  mkdir -p "${MEDIA_ROOT}"
  mkdir -p "${CONFIG_DIR}/portal"

  local configFile=.env

  log "INFO" "Copying files" 1
  cp -Rv "${WORKING_DIR}/." "${INSTALL_DIR}" >> "${LOG_FILE}" 2>&1
  touch "${INSTALL_DIR}/${configFile}"

  if [[ -e /usr/local/sbin/nateflix ]]; then
    rm /usr/local/sbin/nateflix
  fi
  ln -s "${INSTALL_DIR}/bin/nateflix" "/usr/local/sbin/nateflix"

  cd "${INSTALL_DIR}"

  echo "Setting CONFIG_DIR to ${CONFIG_DIR}" >> "${LOG_FILE}"
  echo CONFIG_DIR=${CONFIG_DIR} >> "${INSTALL_DIR}/${configFile}"
  echo "Setting MEDIA_ROOT to ${MEDIA_ROOT}" >> "${LOG_FILE}"
  echo MEDIA_ROOT=${MEDIA_ROOT} >> "${INSTALL_DIR}/${configFile}"
  echo "Setting INSTALL_DIR to ${INSTALL_DIR}" >> "${LOG_FILE}"
  echo INSTALL_DIR=${INSTALL_DIR} >> "${INSTALL_DIR}/${configFile}"
  echo "Setting DOMAIN to ${DOMAIN}" >> "${LOG_FILE}"
  echo DOMAIN=${DOMAIN} >> "${INSTALL_DIR}/${configFile}"
  echo "Setting VPN_REGION to ${VPN_REGION}" >> "${LOG_FILE}"
  echo VPN_REGION=${VPN_REGION} >> "${INSTALL_DIR}/${configFile}"
}

docker_stop()
{
  declare service="$1"
  docker stop "${service}" > /dev/null
  docker rm "${service}" > /dev/null
}

docker_start()
{
  declare service="$1" port="$2" url="$3" status="$4" \
          content="$5" retries="${6:-20}" dont_stop="${7:-0}"

  docker-compose run -d --publish=38258:${port} --name "${service}" "${service}"
  wait_for_service "${url}" ${status} "${content}" ${retries}

  if [[ ${dont_stop} == 0 ]]; then
    docker_stop "${service}"
  fi
}

configure_lidarr()
{
  echo
  echo
  echo "**************************"
  echo "*   CONFIGURING LIDARR   *"
  echo "**************************"
  echo

  log "INFO" "Configuring Lidarr"
  local dbFile="${CONFIG_DIR}/lidarr/lidarr.db"
  if [[ -f "${dbFile}" ]]; then
    log "INFO" "Lidarr already configured; skipping..." 1
    return
  fi

  docker_start "lidarr" 8686 "" 200 "Lidarr" 30

  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('autounmonitorpreviouslydownloadedtracks', 'True')"
  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('deleteemptyfolders', 'True')"
  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('copyusinghardlinks', 'False')"
  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('removecompleteddownloads', 'True')"
  sqlite3 "${dbFile}" "insert into DownloadClients (Enable,Name,Implementation,Settings,ConfigContract) values (1,'nzbget','Nzbget','{\"host\":\"nzbget\",\"port\":6789,\"username\":\"\",\"password\":\"\",\"musicCategory\":\"Music\",\"recentTvPriority\":0,\"olderTvPriority\":0,\"addPaused\":false,\"useSsl\":false}','NzbgetSettings')"
  sqlite3 "${dbFile}" "insert into DownloadClients (Enable,Name,Implementation,Settings,ConfigContract) values (1,'deluge','Deluge','{\"host\":\"deluge\",\"port\":8112,\"username\":\"\",\"password\":\"\",\"musicCategory\":\"lidarr\",\"recentTvPriority\":0,\"olderTvPriority\":0,\"addPaused\":false,\"useSsl\":false}','DelugeSettings')"
  sqlite3 "${dbFile}" "insert into Notifications (Name,OnGrab,OnDownload,Settings,Implementation,ConfigContract,OnUpgrade,Tags,OnRename,OnAlbumDownload) values ('plex',0,1,'{\"host\":\"plex\",\"port\":32400,\"username\":\"${PLEX_USERNAME}\",\"password\":\"${PLEX_PASSWORD}\",\"updateLibrary\":true,\"useSsl\":false,\"isValid\":true}','PlexServer','PlexServerSettings',1,'[]',1,1)"
  sed -i -e "s/<\/Config>/<LaunchBrowser>False<\/LaunchBrowser>\n<\/Config>/" "${CONFIG_DIR}/lidarr/config.xml"
  sed -i -e "s/<\/Config>/<AnalyticsEnabled>False<\/AnalyticsEnabled>\n<\/Config>/" "${CONFIG_DIR}/lidarr/config.xml"
}

configure_plex()
{
  echo
  echo
  echo "**************************"
  echo "*    CONFIGURING PLEX    *"
  echo "**************************"
  echo

  log "INFO" "Configuring Plex"
  if [[ -f "${CONFIG_DIR}/plex/config/Library/Application Support/Plex Media Server/Preferences.xml" ]]; then
    log "INFO" "Plex already configured; skipping..." 1
    return
  fi

  log "INFO" "Getting Plex claim token" 1
  local result=$(curl -s --header "X-Plex-Client-Identifier: Nateflix" \
          --header "X-Plex-Product: Nateflix Installation" \
          --header "X-Plex-Token: ${PLEX_TOKEN}" \
          -X GET https://plex.tv/api/claim/token.json)

  export PLEX_CLAIM=$(echo ${result} | grep -ioe '"token":"[^"]*' | cut -c 10-)
  if [[ -z ${PLEX_CLAIM} ]]; then
    echo "Error retrieving Plex Claim Token"
    echo ${result} >> "${LOG_FILE}"
    exit 1;
  fi

  docker_start "plex" 32400 "/web/index.html" 200 "Plex" 500
}

configure_nzbget()
{
  echo
  echo
  echo "**************************"
  echo "*   CONFIGURING NZBGET   *"
  echo "**************************"
  echo

  log "INFO" "Configuring NzbGet"
  local configFile="${CONFIG_DIR}/nzbget/config/nzbget.conf"
  if [[ -f "${configFile}" ]]; then
    log "INFO" "NzbGet already configured; skipping..." 1
    return
  fi

  docker_start "nzbget" 6789 "" 401 "" 10

  sed -i -e "s/^\(ControlUsername\).\+$/\1=/g" "${configFile}"
  sed -i -e "s/^\(ControlPassword\).\+$/\1=/g" "${configFile}"
}

make_api_call()
{
  declare api_key="$1" url="$2" data="$3"

  curl -Ls -H 'Content-Type: application/json' \
       -H "ApiKey: ${api_key}" \
       -d "${data}" "http://localhost:38258/api/v1/${url}"
}

configure_ombi()
{
  echo
  echo
  echo "**************************"
  echo "*    CONFIGURING OMBI    *"
  echo "**************************"
  echo

  log "INFO" "Configuring OMBI"
  if [[ -f "${CONFIG_DIR}/ombi/Ombi.db" ]]; then
    log "INFO" "OMBI already configured; skipping..." 1
    return
  fi

  docker_start "ombi" 5000 "" 200 "Ombi" 20 1

  local apiKey=$(grep -aioe '"ApiKey":"[^"]*' "${CONFIG_DIR}/ombi/Ombi.db" | cut -c 11-)
  local sonarrKey=$(cat "${CONFIG_DIR}/sonarr/config.xml" | grep -aioe "<ApiKey>[^<]*" | cut -c 9-)
  local radarrKey=$(cat "${CONFIG_DIR}/radarr/config.xml" | grep -aioe "<ApiKey>[^<]*" | cut -c 9-)

  make_api_call "${apiKey}" "Issues/categories" '{"value":"Shows"}'
  make_api_call "${apiKey}" "Issues/categories" '{"value":"Movies"}'
  make_api_call "${apiKey}" "Issues/categories" '{"value":"Foreign Movies"}'
  make_api_call "${apiKey}" "Issues/categories" '{"value":"Anime Movies"}'
  make_api_call "${apiKey}" "Issues/categories" '{"value":"Anime Shows"}'

  make_api_call "${apiKey}" "Settings/customization" "{\"applicationName\":\"Nateflix\",\"applicationUrl\":\"https://request.${DOMAIN}\"}"
  make_api_call "${apiKey}" "Settings/Issues" '{"enabled":true,"enableInProgress":true}'
  make_api_call "${apiKey}" "Settings/authentication" '{"allowNoPassword":false,"enableOAuth":true}'

  local data=$(cat <<- EOD
  {
    "enabled": true,
    "apiKey": "${sonarrKey}",
    "qualityProfile": "6",
    "seasonFolders": true,
    "qualityProfileAnime": "6",
    "addOnly": false,
    "v3": false,
    "ssl": false,
    "ip": "sonarr",
    "port": 8989,
    "id": 0
  }
EOD
)
  make_api_call "${apiKey}" "Settings/sonarr" "${data}"

  data=$(cat <<- EOD
  {
    "id": 1,
    "enabled": true,
    "apiKey": "${radarrKey}",
    "defaultQualityProfile": "6",
    "addOnly": false,
    "minimumAvailability": "Released",
    "ssl": false,
    "ip": "radarr",
    "port": 7878
  }
EOD
)
  make_api_call "${apiKey}" "Settings/radarr" "${data}"

#   data=$(cat <<- EOD
#   {
#     "enable": true,
#     "installId": "string",
#     "servers": [
#       {
#         "name": "Nateflix",
#         "episodeBatchSize": 0,
#         "ssl": true,
#         "ip": "plex",
#         "port": 32400
#       }
#     ]
#   }
# EOD
# )

  data=$(cat <<- EOD
  {
    "enable": true,
    "installId": "48e1cc35-c5cf-4555-8326-27a922fdb749",
    "servers": [
      {
        "name": "Nateflix",
        "plexSelectedLibraries": [
          {
            "enabled": true
          }
        ],
        "ssl": true,
        "ip": "plex",
        "port": 32400
      }
    ],
    "id": 2
  }
EOD
)
  make_api_call "${apiKey}" "Settings/plex" "${data}"

  # {
  #   "servers": [
  #     {
  #       "name": "Server 1",
  #       "plexAuthToken": "<token>",
  #       "machineIdentifier": "",
  #       "episodeBatchSize": 0,
  #       "plexSelectedLibraries": [],
  #       "ssl": false,
  #       "subDir": null,
  #       "ip": "",
  #       "port": 0,
  #       "id": 987987987
  #     }
  #   ],
  # }

  #docker-compose stop ombi
  docker_stop "ombi"
}

configure_sonarr()
{
  echo
  echo
  echo "**************************"
  echo "*   CONFIGURING SONARR   *"
  echo "**************************"
  echo

  log "INFO" "Configuring Sonarr"
  local dbFile="${CONFIG_DIR}/sonarr/nzbdrone.db"
  if [[ -f "${dbFile}" ]]; then
    log "INFO" "Sonarr already configured; skipping..." 1
    return
  fi

  docker_start "sonarr" 8989 "" 200 "Sonarr" 20

  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('cleanupmetadataimages', 'False')"
  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('removecompleteddownloads', 'True')"
  sqlite3 "${dbFile}" "insert into DownloadClients (Enable,Name,Implementation,Settings,ConfigContract) values (1, 'nzbget', 'Nzbget', '{\"host\": \"nzbget\", \"port\": 6789, \"username\": \"\", \"password\": \"\", \"tvCategory\": \"Series\", \"recentTvPriority\": 0, \"olderTvPriority\": 0, \"useSsl\": false}', 'NzbgetSettings')"
  sqlite3 "${dbFile}" "insert into DownloadClients (Enable,Name,Implementation,Settings,ConfigContract) values (1, 'deluge', 'Deluge', '{\"host\": \"deluge\", \"port\": 8112, \"password\": \"\", \"tvCategory\": \"tv-sonarr\", \"recentTvPriority\": 0, \"addPaused\": false, \"olderTvPriority\": 0, \"useSsl\": false}', 'DelugeSettings')"
  sqlite3 "${dbFile}" "insert into Notifications (Name,OnGrab,OnDownload,Settings,Implementation,ConfigContract,OnUpgrade,Tags,OnRename) values ('pms', 0, 1, '{\"host\": \"plex\", \"port\": 32400, \"username\": \"${PLEX_USERNAME}\", \"password\": \"${PLEX_PASSWORD}\", \"updateLibrary\": true, \"useSsl\": false, \"isValid\": true}', 'PlexServer', 'PlexServerSettings', 1, '[]', 1)"
  sqlite3 "${dbFile}" "insert into NamingConfig (MultiEpisodeStyle,RenameEpisodes,StandardEpisodeFormat,DailyEpisodeFormat,SeasonFolderFormat,SeriesFolderFormat,AnimeEpisodeFormat,ReplaceIllegalCharacters) values (0,1,'{Series Title} - S{season:00}E{episode:00} - {Episode Title} {Quality Full}','{Series Title} - {Air-Date} - {Episode Title} {Quality Full}','Season {season}','{Series Title}','{Series Title} - S{season:00}E{episode:00} - {Episode Title} {Quality Full}',1)"
  sed -i -e "s/<LaunchBrowser>True<\/LaunchBrowser>/<LaunchBrowser>False<\/LaunchBrowser>/" "${CONFIG_DIR}/sonarr/config.xml"
  sed -i -e "s/<\/Config>/<AnalyticsEnabled>False<\/AnalyticsEnabled>\n<\/Config>/" "${CONFIG_DIR}/sonarr/config.xml"
}

configure_radarr()
{
  echo
  echo
  echo "**************************"
  echo "*   CONFIGURING RADARR   *"
  echo "**************************"
  echo

  log "INFO" "Configuring Radarr"
  local dbFile="${CONFIG_DIR}/radarr/nzbdrone.db"
  if [[ -f "${dbFile}" ]]; then
    log "INFO" "Radarr already configured; skipping..." 1
    return
  fi

  docker_start "radarr" 7878 "" 200 "Radarr" 20

  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('cleanupmetadataimages', 'False')"
  sqlite3 "${dbFile}" "insert into Config (Key,Value) values ('removecompleteddownloads', 'True')"
  sqlite3 "${dbFile}" "insert into DownloadClients (Enable,Name,Implementation,Settings,ConfigContract) values (1, 'nzbget', 'Nzbget', '{\"host\": \"nzbget\", \"port\": 6789, \"username\": \"\", \"password\": \"\", \"tvCategory\": \"Series\", \"recentTvPriority\": 0, \"olderTvPriority\": 0, \"useSsl\": false}', 'NzbgetSettings')"
  sqlite3 "${dbFile}" "insert into DownloadClients (Enable,Name,Implementation,Settings,ConfigContract) values (1, 'deluge', 'Deluge', '{\"host\": \"deluge\", \"port\": 8112, \"password\": \"\", \"tvCategory\": \"radarr\", \"recentTvPriority\": 0, \"addPaused\": false, \"olderTvPriority\": 0, \"useSsl\": false}', 'DelugeSettings')"
  sqlite3 "${dbFile}" "insert into Notifications (Name,OnGrab,OnDownload,Settings,Implementation,ConfigContract,OnUpgrade,Tags,OnRename) values ('pms', 0, 1, '{\"host\": \"plex\", \"port\": 32400, \"username\": \"${PLEX_USERNAME}\", \"password\": \"${PLEX_PASSWORD}\", \"updateLibrary\": true, \"useSsl\": false, \"isValid\": true}', 'PlexServer', 'PlexServerSettings', 1, '[]', 1)"
  sqlite3 "${dbFile}" "insert into NamingConfig (MultiEpisodeStyle,RenameEpisodes,ReplaceIllegalCharacters,StandardMovieFormat,MovieFolderFormat,ColonReplacementFormat) values (0,1,1,'{Movie Title} {Release Year} {Quality Title}','{Movie Title} ({Release Year})',1)"
  sed -i -e "s/<LaunchBrowser>True<\/LaunchBrowser>/<LaunchBrowser>False<\/LaunchBrowser>/" "${CONFIG_DIR}/radarr/config.xml"
  sed -i -e "s/<\/Config>/<AnalyticsEnabled>False<\/AnalyticsEnabled>\n<\/Config>/" "${CONFIG_DIR}/radarr/config.xml"
}

configure_plexstats()
{
  echo
  echo
  echo "**************************"
  echo "* CONFIGURING PLEX STATS *"
  echo "**************************"
  echo

  log "INFO" "Configuring Plex Stats"
  local configFile="${CONFIG_DIR}/plexstats/config.ini"
  if [[ -f "${configFile}" ]]; then
    log "INFO" "Plex Stats already configured; skipping..." 1
    return
  fi

  docker_start "plexstats" 8181 "" 200 "Tautulli - Welcome" 500

  sed -i -e "s/^\(pms_url\) =.\+$/\1 = http:\/\/plex:32400/g" "${configFile}"
  sed -i -e "s/^\(pms_name\) =.\+$/\1 = ${DOMAIN}/g" "${configFile}"
  sed -i -e "s/^\(pms_plexpass\) =.\+$/\1 = 1/g" "${configFile}"
  sed -i -e "s/^\(pms_port\) =.\+$/\1 = 32400/g" "${configFile}"
  sed -i -e "s/^\(pms_platform\) =.\+$/\1 = Linux/g" "${configFile}"
  sed -i -e "s/^\(pms_ip\) =.\+$/\1 = plex/g" "${configFile}"
  sed -i -e "s/^\(launch_browser\) =.\+$/\1 = 0/g" "${configFile}"
  sed -i -e "s/^\(show_advanced_settings\) =.\+$/\1 = 1/g" "${configFile}"
  sed -i -e "s/^\(pms_logs_folder\) =.\+$/\1 = \/logs/g" "${configFile}"
}

configure_deluge()
{
  echo
  echo
  echo "**************************"
  echo "*   CONFIGURING DELUGE   *"
  echo "**************************"
  echo

  log "INFO" "Configuring Deluge"
  if [[ -f "${CONFIG_DIR}/deluge/core.conf" && -f  "${CONFIG_DIR}/deluge-web/web.conf" ]]; then
    log "INFO" "Deluge already configured; skipping..." 1
    return
  fi

  docker_start "deluge" 8112 "" 200 "Deluge" 20 1
  while [[ ! -f "${CONFIG_DIR}/deluge/auth" ]]; do
    sleep 1s
  done
  docker_stop "deluge"

  echo ${VPN_USERNAME} > "${CONFIG_DIR}/openvpn/auth.txt"
  echo ${VPN_PASSWORD} >> "${CONFIG_DIR}/openvpn/auth.txt"

  # for some reason, this MUST be the last line in the file
  echo "::10" >> "${CONFIG_DIR}/deluge/auth"

  # this will set the password to blank
  sed -i -e "s/^\(.\+\"first_login\": \)true\(.\+\)$/\\1false\\2/g" "${CONFIG_DIR}/deluge-web/web.conf"
  sed -i -e "s/^\(.\+\"pwd_sha1\": \"\)[a-f0-9]\{40\}\(.\+\)$/\\1bc564fecb4c2b1b9380995b28ef2e85298bbfbd1\\2/g" "${CONFIG_DIR}/deluge-web/web.conf"
  sed -i -e "s/^\(.\+\"pwd_salt\": \"\)[a-f0-9]\{40\}\(.\+\)$/\\1b8db8b895fccd7f9aa156fe82ff35744f3f60224\\2/g" "${CONFIG_DIR}/deluge-web/web.conf"
}

configure_portal()
{
  echo
  echo
  echo "**************************"
  echo "*   CONFIGURING PORTAL   *"
  echo "**************************"
  echo

  echo "Copying configuration..."
  cp "${INSTALL_DIR}/portal/config.toml" "${CONFIG_DIR}/portal"
  echo "Creating users..."
  echo ${PORTAL_CREDS} > "${CONFIG_DIR}/portal/users"
}

build_and_configure()
{
  echo
  echo
  echo "**************************"
  echo "*    BUILDING IMAGES     *"
  echo "**************************"
  echo

  export PLEX_CLAIM=""
  docker-compose build --no-cache >> "${LOG_FILE}"
  if [[ $? > 0 ]]; then
    echo "Error building images check log file ${LOG_FILE} for details"
    exit $?
  fi

  configure_portal
  configure_plex
  configure_nzbget
  configure_lidarr
  configure_sonarr
  configure_radarr
  configure_ombi
  configure_plexstats
  configure_deluge
}


if [[ ${EUID} != 0 ]]; then
   echo "This script must be run as root"
   exit 1
fi

WORKING_DIR=$(mktemp -d)
trap "cleanup \"${WORKING_DIR}\"" EXIT


# Check for required packages, distros and ports, exit if missing requirements
check_installed
check_ports
check_distro
check_prereqs

# Install smaller dependencies
install_dependencies

# Gather information from user and perform install
gather_required_config
install

# Build images and configure programs
build_and_configure


echo
echo
echo "Installation complete"
echo
echo

docker-compose up -d

echo
echo "You may need to perform some extra setup steps in each application"
echo "The following domains might also need to be added to your hosts file"
echo
echo "NZBGet:     https://newz.${DOMAIN}"
echo "Plex:       https://watch.${DOMAIN}"
echo "Plex Stats: https://stats.${DOMAIN}"
echo "Lidarr:     https://music.${DOMAIN}"
echo "Sonarr:     https://shows.${DOMAIN}"
echo "Radarr:     https://movies.${DOMAIN}"
echo "OMBI:       https://request.${DOMAIN}"
echo "Deluge:     https://torrents.${DOMAIN}"
echo "Portal:     https://portal.${DOMAIN}"
echo

exit $?

__ARCHIVE__
